name: GraphQL-Inspector

on:
  pull_request:
    branches:
      - main
    types: [opened, synchronize, labeled, unlabeled]

jobs:
  schema-check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout base branch (main)
        uses: actions/checkout@v3
        with:
          ref: ${{ github.base_ref }}
          path: base-branch

      - name: Create old schema file
        run: |
          mkdir -p .github/schemas
          cat base-branch/internal/api/graphql/graph/schema/*.graphqls > .github/schemas/old-schema.graphql

      - name: Checkout PR branch
        uses: actions/checkout@v3
        with:
          path: pr-branch

      - name: Create new schema file
        run: |
          cat pr-branch/internal/api/graphql/graph/schema/*.graphqls > .github/schemas/new-schema.graphql

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install Dependencies
        run: npm install @graphql-inspector/cli

      - name: Check Schema Changes
        id: schema-check
        continue-on-error: true
        run: |
          # Run inspector and capture the output
          INSPECTOR_OUTPUT=$(npx graphql-inspector diff .github/schemas/old-schema.graphql .github/schemas/new-schema.graphql || true)

          # Write output to a file for reference
          echo "$INSPECTOR_OUTPUT" > schema_changes.txt

          # Extract different types of changes
          BREAKING_CHANGES=$(echo "$INSPECTOR_OUTPUT" | grep -E '‚úñ' || echo "")
          DANGEROUS_CHANGES=$(echo "$INSPECTOR_OUTPUT" | grep -E '‚ö†' || echo "")
          SAFE_CHANGES=$(echo "$INSPECTOR_OUTPUT" | grep -E '‚úî' || echo "")

          # Count changes
          BREAKING_COUNT=$(echo "$BREAKING_CHANGES" | grep -c '‚úñ' || echo "0")
          DANGEROUS_COUNT=$(echo "$DANGEROUS_CHANGES" | grep -c '‚ö†' || echo "0")
          SAFE_COUNT=$(echo "$SAFE_CHANGES" | grep -c '‚úî' || echo "0")

          # Write changes to separate files for easier processing
          echo "$BREAKING_CHANGES" > breaking_changes.txt
          echo "$DANGEROUS_CHANGES" > dangerous_changes.txt
          echo "$SAFE_CHANGES" > safe_changes.txt

          # Set output variables
          echo "has_breaking_changes=$([[ $BREAKING_COUNT -gt 0 ]] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "has_dangerous_changes=$([[ $DANGEROUS_COUNT -gt 0 ]] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "has_safe_changes=$([[ $SAFE_COUNT -gt 0 ]] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "breaking_count=$BREAKING_COUNT" >> $GITHUB_OUTPUT
          echo "dangerous_count=$DANGEROUS_COUNT" >> $GITHUB_OUTPUT
          echo "safe_count=$SAFE_COUNT" >> $GITHUB_OUTPUT
          echo "has_any_changes=$([[ $BREAKING_COUNT -gt 0 || $DANGEROUS_COUNT -gt 0 || $SAFE_COUNT -gt 0 ]] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT

      - name: Generate breaking changes report
        if: steps.schema-check.outputs.has_breaking_changes == 'true'
        id: generate-report
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            // Read breaking changes from file
            let breakingChanges = [];
            try {
              const breakingChangesText = fs.readFileSync('breaking_changes.txt', 'utf8');
              breakingChanges = breakingChangesText.split('\n')
                .filter(line => line.trim() !== '')
                .map(line => {
                  // Clean up the log format
                  return line.replace(/\[log\] ‚úñ /, '').trim();
                });
            } catch (error) {
              console.log('Error reading breaking changes file:', error);
              return;
            }

            if (breakingChanges.length > 0) {
              const reportHeader = '## ‚ö†Ô∏è Breaking GraphQL Schema Changes Detected';
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number
              });

              const existingComment = comments.find(comment => comment.body.includes(reportHeader));

              if (!existingComment) {
                let comment = `${reportHeader}\n\n`;
                comment += 'This PR contains breaking changes to the GraphQL schema that need approval:\n\n';

                for (const change of breakingChanges) {
                  comment += `- **BREAKING**: ${change}\n`;
                }

                comment += '\n### Approval Process\n\n';
                comment += 'To approve these breaking changes, add the `approved-schema-change` label to this PR.';

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: comment
                });
              } else {
                console.log('A comment with the change report already exists.');
              }
            }

      - name: Check for approval label
        if: steps.schema-check.outputs.has_breaking_changes == 'true'
        id: check-label
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: labels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const approvedLabel = labels.find(label => label.name === 'approved-schema-change');
            if (approvedLabel) {
              console.log('Approved label found.');
              core.setOutput('approved', 'true');
            } else {
              console.log('Approved label not found.');
              core.setOutput('approved', 'false');
            }

      - name: Send Slack notification for schema changes
        if: steps.schema-check.outputs.has_any_changes == 'true'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            
            // Read change files
            const readChanges = (filename) => {
              try {
                const content = fs.readFileSync(filename, 'utf8');
                return content.split('\n')
                  .filter(line => line.trim() !== '')
                  .map(line => line.replace(/\[log\] [‚úñ‚ö†‚úî] /, '').trim());
              } catch (error) {
                return [];
              }
            };

            const breakingChanges = readChanges('breaking_changes.txt');
            const dangerousChanges = readChanges('dangerous_changes.txt');
            const safeChanges = readChanges('safe_changes.txt');

            // Determine message color and priority
            let color = '#36a64f'; // Green for safe changes
            let priority = 'Safe';
            
            if (breakingChanges.length > 0) {
              color = '#ff0000'; // Red for breaking changes
              priority = 'Breaking';
            } else if (dangerousChanges.length > 0) {
              color = '#ffaa00'; // Orange for dangerous changes
              priority = 'Dangerous';
            }

            // Build Slack message
            const prUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${context.issue.number}`;
            const prTitle = context.payload.pull_request.title;
            const prAuthor = context.payload.pull_request.user.login;

            let message = {
              "attachments": [
                {
                  "color": color,
                  "title": `üîÑ GraphQL Schema Changes Detected - ${priority} Priority`,
                  "title_link": prUrl,
                  "fields": [
                    {
                      "title": "Pull Request",
                      "value": `<${prUrl}|#${context.issue.number}: ${prTitle}>`,
                      "short": false
                    },
                    {
                      "title": "Author",
                      "value": prAuthor,
                      "short": true
                    },
                    {
                      "title": "Repository",
                      "value": `${context.repo.owner}/${context.repo.repo}`,
                      "short": true
                    }
                  ]
                }
              ]
            };

            // Add change details
            let changeText = "";
            
            if (breakingChanges.length > 0) {
              changeText += `üö® *Breaking Changes (${breakingChanges.length}):*\n`;
              breakingChanges.forEach(change => {
                changeText += `‚Ä¢ ${change}\n`;
              });
              changeText += "\n";
            }
            
            if (dangerousChanges.length > 0) {
              changeText += `‚ö†Ô∏è *Dangerous Changes (${dangerousChanges.length}):*\n`;
              dangerousChanges.forEach(change => {
                changeText += `‚Ä¢ ${change}\n`;
              });
              changeText += "\n";
            }
            
            if (safeChanges.length > 0) {
              changeText += `‚úÖ *Safe Changes (${safeChanges.length}):*\n`;
              safeChanges.forEach(change => {
                changeText += `‚Ä¢ ${change}\n`;
              });
            }

            message.attachments[0].text = changeText;

            // Add mentions for team members
            const mentions = "<@hoda.noori@sap.com> <@a.reuschenbach.puncernau@sap.com> <@taimoor.aslam@sap.com>";
            message.text = `${mentions} - GraphQL schema changes detected in PR`;

            // Add approval status for breaking changes
            if (breakingChanges.length > 0) {
              const approvalStatus = '${{ steps.check-label.outputs.approved }}' === 'true' ? 
                '‚úÖ *Approved* - Breaking changes have been approved' : 
                '‚ùå *Needs Approval* - Add `approved-schema-change` label to approve';
              
              message.attachments[0].fields.push({
                "title": "Approval Status",
                "value": approvalStatus,
                "short": false
              });
            }

            // Send to Slack
            const slackPayload = JSON.stringify(message);
            
            const https = require('https');
            const webhookUrl = process.env.SLACK_WEBHOOK_HEUREKA_DEV|| '${{ secrets.SLACK_WEBHOOK_HEUREKA_DEV}}';
            
            if (!webhookUrl) {
              console.log('SLACK_WEBHOOK_HEUREKA_DEVnot configured, skipping Slack notification');
              return;
            }

            const url = new URL(webhookUrl);
            const options = {
              hostname: url.hostname,
              port: 443,
              path: url.pathname,
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(slackPayload)
              }
            };

            const req = https.request(options, (res) => {
              console.log(`Slack notification sent. Status: ${res.statusCode}`);
            });

            req.on('error', (error) => {
              console.error('Error sending Slack notification:', error);
            });

            req.write(slackPayload);
            req.end();

      - name: Fail if breaking changes are not approved
        if: steps.schema-check.outputs.has_breaking_changes == 'true' && steps.check-label.outputs.approved != 'true'
        run: |
          echo "‚ùå Breaking schema changes detected and not approved."
          echo "Please approve the breaking changes by adding the 'approved-schema-change' label to the PR."
          echo "Breaking changes detected: $(cat breaking_changes.txt)"
          exit 1

      - name: Pass check if breaking changes are approved
        if: steps.schema-check.outputs.has_breaking_changes == 'true' && steps.check-label.outputs.approved == 'true'
        run: |
          echo "‚úÖ Breaking schema changes have been approved with the 'approved-schema-change' label."
          echo "Approved changes: $(cat breaking_changes.txt)"
