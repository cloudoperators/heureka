package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"

	"github.com/cloudoperators/heureka/internal/api/graphql/graph"
	"github.com/cloudoperators/heureka/internal/api/graphql/graph/baseResolver"
	"github.com/cloudoperators/heureka/internal/api/graphql/graph/model"
	"github.com/samber/lo"
)

// SPDX-FileCopyrightText: 2025 SAP SE or an SAP affiliate company and Greenhouse contributors
// SPDX-License-Identifier: Apache-2.0

func (r *vulnerabilityResolver) Severity(ctx context.Context, obj *model.Vulnerability) (*model.SeverityValues, error) {
	first := lo.ToPtr(1)
	order := []*model.IssueMatchOrderBy{
		{
			By:        lo.ToPtr(model.IssueMatchOrderByFieldSeverity),
			Direction: lo.ToPtr(model.OrderDirectionDesc),
		},
	}
	im, err := baseResolver.IssueMatchBaseResolver(r.App, ctx, nil, first, nil, order, &model.NodeParent{
		Parent:     obj,
		ParentName: model.VulnerabilityNodeName,
	})

	if err != nil {
		return nil, err
	}

	if len(im.Edges) == 0 {
		return nil, nil // No issue match found
	}

	return im.Edges[0].Node.Severity.Value, nil
}

func (r *vulnerabilityResolver) SourceURL(ctx context.Context, obj *model.Vulnerability) (*string, error) {
	first := lo.ToPtr(1)
	iv, err := baseResolver.IssueVariantBaseResolver(r.App, ctx, nil, first, nil, &model.NodeParent{
		Parent:     obj,
		ParentName: model.IssueNodeName,
	})

	if err != nil {
		return nil, err
	}

	if len(iv.Edges) == 0 {
		return nil, nil // No issue variant found
	}

	return iv.Edges[0].Node.ExternalURL, nil
}

func (r *vulnerabilityResolver) EarliestTargetRemediationDate(ctx context.Context, obj *model.Vulnerability) (*string, error) {
	first := lo.ToPtr(1)
	order := []*model.IssueMatchOrderBy{
		{
			By:        lo.ToPtr(model.IssueMatchOrderByFieldTargetRemediationDate),
			Direction: lo.ToPtr(model.OrderDirectionAsc),
		},
	}
	im, err := baseResolver.IssueMatchBaseResolver(r.App, ctx, nil, first, nil, order, &model.NodeParent{
		Parent:     obj,
		ParentName: model.VulnerabilityNodeName,
	})

	if err != nil {
		return nil, err
	}

	if len(im.Edges) == 0 {
		return nil, nil // No issue match found
	}

	return im.Edges[0].Node.TargetRemediationDate, nil
}

func (r *vulnerabilityResolver) Services(ctx context.Context, obj *model.Vulnerability, first *int, after *string) (*model.ServiceConnection, error) {
	order := []*model.ServiceOrderBy{
		{
			By:        lo.ToPtr(model.ServiceOrderByFieldCcrn),
			Direction: lo.ToPtr(model.OrderDirectionAsc),
		},
	}
	return baseResolver.ServiceBaseResolver(r.App, ctx, nil, first, after, order, &model.NodeParent{
		Parent:     obj,
		ParentName: model.VulnerabilityNodeName,
	})
}

func (r *Resolver) Vulnerability() graph.VulnerabilityResolver { return &vulnerabilityResolver{r} }

type vulnerabilityResolver struct{ *Resolver }
