// SPDX-FileCopyrightText: 2025 SAP SE or an SAP affiliate company and Greenhouse contributors
// SPDX-License-Identifier: Apache-2.0

package baseResolver

import (
	"context"

	"github.com/cloudoperators/heureka/internal/api/graphql/graph/model"
	"github.com/cloudoperators/heureka/internal/app"
	"github.com/cloudoperators/heureka/internal/entity"
	"github.com/samber/lo"
	"github.com/sirupsen/logrus"
)

func VulnerabilityBaseResolver(app app.Heureka, ctx context.Context, filter *model.VulnerabilityFilter, first *int, after *string) (*model.VulnerabilityConnection, error) {
	requestedFields := GetPreloads(ctx)
	logrus.WithFields(logrus.Fields{
		"requestedFields": requestedFields,
	}).Debug("Called VulnerabilityBaseResolver")

	if filter == nil {
		filter = &model.VulnerabilityFilter{}
	}

	f := &entity.IssueFilter{
		PaginatedX:       entity.PaginatedX{First: first, After: after},
		SupportGroupCCRN: filter.SupportGroup,
		Type:             []*string{lo.ToPtr(entity.IssueTypeVulnerability.String())},
		Search:           filter.Search,
		HasIssueMatches:  true,
		IssueMatchStatus: []*string{lo.ToPtr(entity.IssueMatchStatusValuesNew.String())},
	}

	opt := GetIssueListOptions(requestedFields)
	// Set default ordering
	opt.Order = append(opt.Order, entity.Order{
		By:        entity.IssueVariantRating,
		Direction: entity.OrderDirectionDesc,
	})
	opt.Order = append(opt.Order, entity.Order{
		By:        entity.IssuePrimaryName,
		Direction: entity.OrderDirectionAsc,
	})

	issues, err := app.ListIssues(f, opt)

	if err != nil {
		return nil, NewResolverError("VulnerabilityBaseResolver", err.Error())
	}

	edges := []*model.VulnerabilityEdge{}
	for _, result := range issues.Elements {
		vulnerability := model.NewVulnerability(result.Issue)
		edge := model.VulnerabilityEdge{
			Node:   &vulnerability,
			Cursor: result.Cursor(),
		}
		edges = append(edges, &edge)
	}

	totalCount := 0
	if issues.TotalCount != nil {
		totalCount = int(*issues.TotalCount)
	}

	connection := model.VulnerabilityConnection{
		TotalCount: totalCount,
		Edges:      edges,
		PageInfo:   model.NewPageInfo(issues.PageInfo),
	}

	return &connection, nil
}
